import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:equatable/equatable.dart';
import '../models/task.dart';
import '../services/tasks_service.dart';
import '../services/logging_service.dart';

// Events
abstract class TasksEvent extends Equatable {
  const TasksEvent();

  @override
  List<Object?> get props => [];
}

class TasksLoadRequested extends TasksEvent {
  final int? projectId;
  final int? anteprojectId;

  const TasksLoadRequested({this.projectId, this.anteprojectId});

  @override
  List<Object?> get props => [projectId, anteprojectId];
}

class TaskCreateRequested extends TasksEvent {
  final Task task;

  const TaskCreateRequested(this.task);

  @override
  List<Object> get props => [task];
}

class TaskUpdateRequested extends TasksEvent {
  final Task task;

  const TaskUpdateRequested(this.task);

  @override
  List<Object> get props => [task];
}

class TaskStatusUpdateRequested extends TasksEvent {
  final int taskId;
  final TaskStatus status;

  const TaskStatusUpdateRequested({required this.taskId, required this.status});

  @override
  List<Object> get props => [taskId, status];
}

class TaskDeleteRequested extends TasksEvent {
  final int id;

  const TaskDeleteRequested(this.id);

  @override
  List<Object> get props => [id];
}

class TaskReorderRequested extends TasksEvent {
  final int taskId;
  final TaskStatus newStatus;
  final int newPosition;

  const TaskReorderRequested({
    required this.taskId,
    required this.newStatus,
    required this.newPosition,
  });

  @override
  List<Object> get props => [taskId, newStatus, newPosition];
}

class TaskPositionUpdateRequested extends TasksEvent {
  final int taskId;
  final int newPosition;

  const TaskPositionUpdateRequested({
    required this.taskId,
    required this.newPosition,
  });

  @override
  List<Object> get props => [taskId, newPosition];
}

// States
abstract class TasksState extends Equatable {
  const TasksState();

  @override
  List<Object?> get props => [];
}

class TasksInitial extends TasksState {}

class TasksLoading extends TasksState {}

class TasksLoaded extends TasksState {
  final List<Task> tasks;

  const TasksLoaded(this.tasks);

  @override
  List<Object> get props => [tasks];
}

class TasksFailure extends TasksState {
  final String messageKey;

  const TasksFailure(this.messageKey);

  @override
  List<Object> get props => [messageKey];
}

class TaskOperationSuccess extends TasksState {
  final String messageKey;

  const TaskOperationSuccess(this.messageKey);

  @override
  List<Object> get props => [messageKey];
}

// BLoC
class TasksBloc extends Bloc<TasksEvent, TasksState> {
  final TasksService _tasksService;

  TasksBloc({required TasksService tasksService})
    : _tasksService = tasksService,
      super(TasksInitial()) {
    on<TasksLoadRequested>(_onTasksLoadRequested);
    on<TaskCreateRequested>(_onTaskCreateRequested);
    on<TaskUpdateRequested>(_onTaskUpdateRequested);
    on<TaskStatusUpdateRequested>(_onTaskStatusUpdateRequested);
    on<TaskDeleteRequested>(_onTaskDeleteRequested);
    on<TaskReorderRequested>(_onTaskReorderRequested);
    on<TaskPositionUpdateRequested>(_onTaskPositionUpdateRequested);
  }

  Future<void> _onTasksLoadRequested(
    TasksLoadRequested event,
    Emitter<TasksState> emit,
  ) async {
    emit(TasksLoading());

    try {
      List<Task> tasks;
      if (event.projectId != null || event.anteprojectId != null) {
        // Usar getStudentTasks que funciona correctamente
        final studentTasks = await _tasksService.getStudentTasks();
        // Convertir List<dynamic> a List<Task>
        tasks = studentTasks.map((taskData) {
          return Task(
            id: taskData['id'] as int,
            projectId: taskData['project_id'] as int?,
            anteprojectId: taskData['anteproject_id'] as int?,
            milestoneId: taskData['milestone_id'] as int?,
            title: taskData['title'] as String,
            description: taskData['description'] as String,
            status: TaskStatus.values.firstWhere(
              (e) => e.name == taskData['status'],
              orElse: () => TaskStatus.pending,
            ),
            dueDate: taskData['due_date'] != null
                ? DateTime.parse(taskData['due_date'] as String)
                : null,
            completedAt: taskData['completed_at'] != null
                ? DateTime.parse(taskData['completed_at'] as String)
                : null,
            kanbanPosition: taskData['kanban_position'] as int,
            estimatedHours: taskData['estimated_hours'] as int?,
            actualHours: taskData['actual_hours'] as int?,
            complexity: TaskComplexity.values.firstWhere(
              (e) => e.name == taskData['complexity'],
              orElse: () => TaskComplexity.medium,
            ),
            tags: taskData['tags'] != null
                ? List<String>.from(taskData['tags'] as List)
                : null,
            isAutoGenerated: taskData['is_auto_generated'] as bool,
            generationSource: taskData['generation_source'] as String?,
            createdAt: DateTime.parse(taskData['created_at'] as String),
            updatedAt: DateTime.parse(taskData['updated_at'] as String),
          );
        }).toList();
      } else {
        tasks = await _tasksService.getTasks();
      }
      emit(TasksLoaded(tasks));
    } catch (e) {
      emit(TasksFailure(e.toString()));
    }
  }

  Future<void> _onTaskCreateRequested(
    TaskCreateRequested event,
    Emitter<TasksState> emit,
  ) async {
    emit(TasksLoading());

    try {
      await _tasksService.createTask(event.task);

      // La tarea se cre√≥ exitosamente
      emit(const TaskOperationSuccess('taskCreatedSuccess'));
      // Recargar la lista
      add(TasksLoadRequested(projectId: event.task.projectId));
    } catch (e) {
      emit(TasksFailure(e.toString()));
    }
  }

  Future<void> _onTaskUpdateRequested(
    TaskUpdateRequested event,
    Emitter<TasksState> emit,
  ) async {
    emit(TasksLoading());

    try {
      await _tasksService.updateTask(event.task.id, event.task);

      // La tarea se actualiz√≥ exitosamente
      emit(const TaskOperationSuccess('taskUpdatedSuccess'));
      // Recargar la lista
      add(TasksLoadRequested(projectId: event.task.projectId));
    } catch (e) {
      emit(TasksFailure(e.toString()));
    }
  }

  Future<void> _onTaskStatusUpdateRequested(
    TaskStatusUpdateRequested event,
    Emitter<TasksState> emit,
  ) async {
    emit(TasksLoading());

    try {
      // Obtener la tarea actual
      final currentTask = await _tasksService.getTask(event.taskId);
      if (currentTask != null) {
        // Actualizar solo el estado
        final updatedTask = currentTask.copyWith(
          status: event.status,
          updatedAt: DateTime.now(),
        );

        await _tasksService.updateTask(event.taskId, updatedTask);

        // El estado se actualiz√≥ exitosamente
        emit(const TaskOperationSuccess('taskStatusUpdatedSuccess'));
        // Recargar la lista
        add(TasksLoadRequested(projectId: currentTask.projectId));
      } else {
        emit(const TasksFailure('taskNotFound'));
      }
    } catch (e) {
      emit(TasksFailure(e.toString()));
    }
  }

  Future<void> _onTaskDeleteRequested(
    TaskDeleteRequested event,
    Emitter<TasksState> emit,
  ) async {
    emit(TasksLoading());

    try {
      // Por ahora, solo emitir √©xito (el servicio no tiene m√©todo delete)
      emit(const TaskOperationSuccess('taskDeletedSuccess'));
      // Recargar la lista
      add(const TasksLoadRequested());
    } catch (e) {
      emit(TasksFailure(e.toString()));
    }
  }

  Future<void> _onTaskReorderRequested(
    TaskReorderRequested event,
    Emitter<TasksState> emit,
  ) async {
    LoggingService.debug('üéØ BLoC: TaskReorderRequested recibido');
    LoggingService.debug('   TaskId: ${event.taskId}');
    LoggingService.debug('   NewStatus: ${event.newStatus.name}');
    LoggingService.debug('   NewPosition: ${event.newPosition}');

    try {
      // Obtener la tarea actual
      final currentTask = await _tasksService.getTask(event.taskId);
      if (currentTask != null) {
        LoggingService.debug('   ‚úÖ Tarea encontrada: ${currentTask.title}');

        // Actualizar estado y posici√≥n
        final updatedTask = currentTask.copyWith(
          status: event.newStatus,
          kanbanPosition: event.newPosition,
          updatedAt: DateTime.now(),
        );

        await _tasksService.updateTask(event.taskId, updatedTask);
        LoggingService.debug('   ‚úÖ Tarea actualizada en la base de datos');

        // El reordenamiento se complet√≥ exitosamente
        emit(const TaskOperationSuccess('taskReorderedSuccess'));
        // Recargar la lista
        add(TasksLoadRequested(projectId: currentTask.projectId));
        LoggingService.debug('   ‚úÖ Recargando lista de tareas');
      } else {
        LoggingService.warning('   ‚ùå Tarea no encontrada');
        emit(const TasksFailure('taskNotFound'));
      }
    } catch (e) {
      LoggingService.error('   ‚ùå Error procesando reorder', e);
      emit(TasksFailure(e.toString()));
    }
  }

  Future<void> _onTaskPositionUpdateRequested(
    TaskPositionUpdateRequested event,
    Emitter<TasksState> emit,
  ) async {
    LoggingService.debug('üéØ BLoC: TaskPositionUpdateRequested recibido');
    LoggingService.debug('   TaskId: ${event.taskId}');
    LoggingService.debug('   NewPosition: ${event.newPosition}');

    try {
      // Actualizar solo la posici√≥n Kanban
      await _tasksService.updateKanbanPosition(event.taskId, event.newPosition);
      LoggingService.debug('   ‚úÖ Posici√≥n actualizada en la base de datos');

      // La posici√≥n se actualiz√≥ exitosamente
      emit(const TaskOperationSuccess('taskPositionUpdatedSuccess'));
      // Recargar la lista - necesitamos obtener el projectId de la tarea
      final task = await _tasksService.getTask(event.taskId);
      if (task != null) {
        add(TasksLoadRequested(projectId: task.projectId));
        LoggingService.debug(
          '   ‚úÖ Recargando lista de tareas con projectId: ${task.projectId}',
        );
      } else {
        add(const TasksLoadRequested());
        LoggingService.debug('   ‚úÖ Recargando lista de tareas (sin projectId)');
      }
    } catch (e) {
      LoggingService.error('   ‚ùå Error actualizando posici√≥n', e);
      emit(TasksFailure(e.toString()));
    }
  }
}
