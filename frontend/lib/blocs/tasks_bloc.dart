import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:equatable/equatable.dart';
import '../models/task.dart';
import '../services/tasks_service.dart';

// Events
abstract class TasksEvent extends Equatable {
  const TasksEvent();

  @override
  List<Object?> get props => [];
}

class TasksLoadRequested extends TasksEvent {
  final int? projectId;
  final int? anteprojectId;

  const TasksLoadRequested({this.projectId, this.anteprojectId});

  @override
  List<Object?> get props => [projectId, anteprojectId];
}

class TaskCreateRequested extends TasksEvent {
  final Task task;

  const TaskCreateRequested(this.task);

  @override
  List<Object> get props => [task];
}

class TaskUpdateRequested extends TasksEvent {
  final Task task;

  const TaskUpdateRequested(this.task);

  @override
  List<Object> get props => [task];
}

class TaskStatusUpdateRequested extends TasksEvent {
  final int taskId;
  final TaskStatus status;

  const TaskStatusUpdateRequested({
    required this.taskId,
    required this.status,
  });

  @override
  List<Object> get props => [taskId, status];
}

class TaskDeleteRequested extends TasksEvent {
  final int id;

  const TaskDeleteRequested(this.id);

  @override
  List<Object> get props => [id];
}

// States
abstract class TasksState extends Equatable {
  const TasksState();

  @override
  List<Object?> get props => [];
}

class TasksInitial extends TasksState {}

class TasksLoading extends TasksState {}

class TasksLoaded extends TasksState {
  final List<Task> tasks;

  const TasksLoaded(this.tasks);

  @override
  List<Object> get props => [tasks];
}

class TasksFailure extends TasksState {
  final String messageKey;

  const TasksFailure(this.messageKey);

  @override
 List<Object> get props => [messageKey];
}

class TaskOperationSuccess extends TasksState {
  final String messageKey;

  const TaskOperationSuccess(this.messageKey);

  @override
  List<Object> get props => [messageKey];
}

// BLoC
class TasksBloc extends Bloc<TasksEvent, TasksState> {
  final TasksService _tasksService;

  TasksBloc({required TasksService tasksService})
      : _tasksService = tasksService,
        super(TasksInitial()) {
    
    on<TasksLoadRequested>(_onTasksLoadRequested);
    on<TaskCreateRequested>(_onTaskCreateRequested);
    on<TaskUpdateRequested>(_onTaskUpdateRequested);
    on<TaskStatusUpdateRequested>(_onTaskStatusUpdateRequested);
    on<TaskDeleteRequested>(_onTaskDeleteRequested);
  }

  Future<void> _onTasksLoadRequested(
    TasksLoadRequested event,
    Emitter<TasksState> emit,
  ) async {
    emit(TasksLoading());
    
    try {
      List<Task> tasks;
      if (event.projectId != null || event.anteprojectId != null) {
        // Usar getStudentTasks que funciona correctamente
        final studentTasks = await _tasksService.getStudentTasks();
        // Convertir List<dynamic> a List<Task>
        tasks = studentTasks.map((taskData) {
          return Task(
            id: taskData['id'] as int,
            projectId: taskData['project_id'] as int?,
            anteprojectId: taskData['anteproject_id'] as int?,
            milestoneId: taskData['milestone_id'] as int?,
            title: taskData['title'] as String,
            description: taskData['description'] as String,
            status: TaskStatus.values.firstWhere(
              (e) => e.name == taskData['status'],
              orElse: () => TaskStatus.pending,
            ),
            dueDate: taskData['due_date'] != null 
                ? DateTime.parse(taskData['due_date'] as String)
                : null,
            completedAt: taskData['completed_at'] != null 
                ? DateTime.parse(taskData['completed_at'] as String)
                : null,
            kanbanPosition: taskData['kanban_position'] as int,
            estimatedHours: taskData['estimated_hours'] as int?,
            actualHours: taskData['actual_hours'] as int?,
            complexity: TaskComplexity.values.firstWhere(
              (e) => e.name == taskData['complexity'],
              orElse: () => TaskComplexity.medium,
            ),
            tags: taskData['tags'] != null 
                ? List<String>.from(taskData['tags'] as List)
                : null,
            isAutoGenerated: taskData['is_auto_generated'] as bool,
            generationSource: taskData['generation_source'] as String?,
            createdAt: DateTime.parse(taskData['created_at'] as String),
            updatedAt: DateTime.parse(taskData['updated_at'] as String),
          );
        }).toList();
      } else {
        tasks = await _tasksService.getTasks();
      }
      emit(TasksLoaded(tasks));
    } catch (e) {
      emit(TasksFailure(e.toString()));
    }
  }

  Future<void> _onTaskCreateRequested(
    TaskCreateRequested event,
    Emitter<TasksState> emit,
  ) async {
    emit(TasksLoading());
    
    try {
      await _tasksService.createTask(event.task);
      
      // La tarea se creó exitosamente
      emit(const TaskOperationSuccess('taskCreatedSuccess'));
      // Recargar la lista
      add(TasksLoadRequested(projectId: event.task.projectId));
    } catch (e) {
      emit(TasksFailure(e.toString()));
    }
  }

  Future<void> _onTaskUpdateRequested(
    TaskUpdateRequested event,
    Emitter<TasksState> emit,
  ) async {
    emit(TasksLoading());
    
    try {
      await _tasksService.updateTask(
        event.task.id,
        event.task,
      );
      
      // La tarea se actualizó exitosamente
      emit(const TaskOperationSuccess('taskUpdatedSuccess'));
      // Recargar la lista
      add(TasksLoadRequested(projectId: event.task.projectId));
    } catch (e) {
      emit(TasksFailure(e.toString()));
    }
  }

  Future<void> _onTaskStatusUpdateRequested(
    TaskStatusUpdateRequested event,
    Emitter<TasksState> emit,
  ) async {
    emit(TasksLoading());
    
    try {
      // Obtener la tarea actual
      final currentTask = await _tasksService.getTask(event.taskId);
      if (currentTask != null) {
        // Actualizar solo el estado
        final updatedTask = currentTask.copyWith(
          status: event.status,
          updatedAt: DateTime.now(),
        );
        
        await _tasksService.updateTask(
          event.taskId,
          updatedTask,
        );
        
        // El estado se actualizó exitosamente
        emit(const TaskOperationSuccess('taskStatusUpdatedSuccess'));
        // Recargar la lista
        add(TasksLoadRequested(projectId: currentTask.projectId));
      } else {
        emit(const TasksFailure('taskNotFound'));
      }
    } catch (e) {
      emit(TasksFailure(e.toString()));
    }
  }

  Future<void> _onTaskDeleteRequested(
    TaskDeleteRequested event,
    Emitter<TasksState> emit,
  ) async {
    emit(TasksLoading());
    
    try {
      // Por ahora, solo emitir éxito (el servicio no tiene método delete)
      emit(const TaskOperationSuccess('taskDeletedSuccess'));
      // Recargar la lista
      add(const TasksLoadRequested());
    } catch (e) {
      emit(TasksFailure(e.toString()));
    }
  }
}
