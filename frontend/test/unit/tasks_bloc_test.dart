import 'package:flutter_test/flutter_test.dart';
import 'package:bloc_test/bloc_test.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';

import 'package:frontend/blocs/tasks_bloc.dart';
import 'package:frontend/models/task.dart';
import 'package:frontend/services/tasks_service.dart';

// Generar mocks
@GenerateMocks([TasksService])
import 'tasks_bloc_test.mocks.dart';

void main() {
  group('TasksBloc', () {
    late MockTasksService mockTasksService;
    late TasksBloc tasksBloc;

    setUp(() {
      mockTasksService = MockTasksService();
      tasksBloc = TasksBloc(tasksService: mockTasksService);
    });

    tearDown(() {
      tasksBloc.close();
    });

    test('initial state is TasksInitial', () {
      expect(tasksBloc.state, isA<TasksInitial>());
    });

    group('TasksLoadRequested', () {
      blocTest<TasksBloc, TasksState>(
        'emits [TasksLoading, TasksLoaded] when tasks are loaded successfully',
        build: () {
          final testTasks = [
            Task(
              id: 1,
              projectId: 1,
              title: 'Test Task 1',
              description: 'Test Description 1',
              status: TaskStatus.pending,
              kanbanPosition: 1,
              complexity: TaskComplexity.simple,
              isAutoGenerated: false,
              createdAt: DateTime(2024, 1, 1),
              updatedAt: DateTime(2024, 1, 1),
            ),
            Task(
              id: 2,
              projectId: 1,
              title: 'Test Task 2',
              description: 'Test Description 2',
              status: TaskStatus.inProgress,
              kanbanPosition: 2,
              complexity: TaskComplexity.medium,
              isAutoGenerated: false,
              createdAt: DateTime(2024, 1, 1),
              updatedAt: DateTime(2024, 1, 1),
            ),
          ];
          when(mockTasksService.getTasksByProject(1)).thenAnswer((_) async => testTasks);
          return tasksBloc;
        },
        act: (bloc) => bloc.add(const TasksLoadRequested(projectId: 1)),
        expect: () => [
          isA<TasksLoading>(),
          isA<TasksLoaded>(),
        ],
        verify: (_) {
          verify(mockTasksService.getTasksByProject(1)).called(1);
        },
      );

      blocTest<TasksBloc, TasksState>(
        'emits [TasksLoading, TasksFailure] when loading fails',
        build: () {
          when(mockTasksService.getTasksByProject(1)).thenThrow(Exception('Failed to load tasks'));
          return tasksBloc;
        },
        act: (bloc) => bloc.add(const TasksLoadRequested(projectId: 1)),
        expect: () => [
          isA<TasksLoading>(),
          isA<TasksFailure>(),
        ],
        verify: (_) {
          verify(mockTasksService.getTasksByProject(1)).called(1);
        },
      );
    });

    group('TaskCreateRequested', () {
              blocTest<TasksBloc, TasksState>(
          'emits [TasksLoading, TaskOperationSuccess] when task is created successfully',
          build: () {
            final testTask = Task(
              id: 1,
              projectId: 1,
              title: 'New Task',
              description: 'New Description',
              status: TaskStatus.pending,
              kanbanPosition: 1,
              complexity: TaskComplexity.simple,
              isAutoGenerated: false,
              createdAt: DateTime(2024, 1, 1),
              updatedAt: DateTime(2024, 1, 1),
            );
            when(mockTasksService.createTask(any)).thenAnswer((_) async => testTask);
            // Mock getTasksByProject para la recarga automática
            when(mockTasksService.getTasksByProject(1)).thenAnswer((_) async => [testTask]);
            return tasksBloc;
          },
        act: (bloc) {
          final newTask = Task(
            id: 0, // ID temporal para creación
            projectId: 1,
            title: 'New Task',
            description: 'New Description',
            status: TaskStatus.pending,
            kanbanPosition: 1,
            complexity: TaskComplexity.simple,
            isAutoGenerated: false,
            createdAt: DateTime(2024, 1, 1),
            updatedAt: DateTime(2024, 1, 1),
          );
          bloc.add(TaskCreateRequested(newTask));
        },
        expect: () => [
          isA<TasksLoading>(),
          isA<TaskOperationSuccess>(),
          isA<TasksLoading>(),
          isA<TasksLoaded>(),
        ],
        verify: (_) {
          verify(mockTasksService.createTask(any)).called(1);
          verify(mockTasksService.getTasksByProject(1)).called(1);
        },
      );
    });

    group('TaskUpdateRequested', () {
              blocTest<TasksBloc, TasksState>(
          'emits [TasksLoading, TaskOperationSuccess] when task is updated successfully',
          build: () {
            final testTask = Task(
              id: 1,
              projectId: 1,
              title: 'Updated Task',
              description: 'Updated Description',
              status: TaskStatus.inProgress,
              kanbanPosition: 1,
              complexity: TaskComplexity.medium,
              isAutoGenerated: false,
              createdAt: DateTime(2024, 1, 1),
              updatedAt: DateTime(2024, 1, 1),
            );
            when(mockTasksService.updateTask(1, any)).thenAnswer((_) async => testTask);
            // Mock getTasksByProject para la recarga automática
            when(mockTasksService.getTasksByProject(1)).thenAnswer((_) async => [testTask]);
            return tasksBloc;
          },
        act: (bloc) {
          final updatedTask = Task(
            id: 1,
            projectId: 1,
            title: 'Updated Task',
            description: 'Updated Description',
            status: TaskStatus.inProgress,
            kanbanPosition: 1,
            complexity: TaskComplexity.medium,
            isAutoGenerated: false,
            createdAt: DateTime(2024, 1, 1),
            updatedAt: DateTime(2024, 1, 1),
          );
          bloc.add(TaskUpdateRequested(updatedTask));
        },
        expect: () => [
          isA<TasksLoading>(),
          isA<TaskOperationSuccess>(),
          isA<TasksLoading>(),
          isA<TasksLoaded>(),
        ],
        verify: (_) {
          verify(mockTasksService.updateTask(1, any)).called(1);
          verify(mockTasksService.getTasksByProject(1)).called(1);
        },
      );
    });
  });
}
